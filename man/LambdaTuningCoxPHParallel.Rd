% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/TimeToEvent.R
\name{LambdaTuningCoxPHParallel}
\alias{LambdaTuningCoxPHParallel}
\title{Run LambdaTuningCoxPH in Parallel}
\usage{
LambdaTuningCoxPHParallel(
  X_scale,
  X_raw,
  event,
  duration,
  lmbdrange,
  n_cores,
  outpath,
  spl_ratio = 0.7,
  run_echo = FALSE,
  max_iter = 10000,
  tol = 1e-04,
  lr = 0.001,
  alpha = 0.9,
  epsilon = 1e-08
)
}
\arguments{
\item{X_scale}{Matrix or DataFrame. Scaled data with samples as rows and features as columns, used for machine learning. If no scaled data is provided, raw count data may be used.}

\item{X_raw}{Matrix or DataFrame. Raw count data with samples as rows and features as columns, used to calculate feature prevalence.}

\item{event}{Numeric vector. Binary indicator for event status: 1 for event occurrence (e.g., death), and 0 for censored (e.g., alive).}

\item{duration}{Numeric vector. Duration of follow-up time for each sample.}

\item{lmbdrange}{Numeric vector. Examining log-lambda vector, provided form `AutoScanningCoxPH`.}

\item{n_cores}{Integer. Number of cores for parallel processing.}

\item{outpath}{Character. The absolute-path of output folder for saving tuning result.}

\item{spl_ratio}{Numeric. The splits ratio for training part (default is 0.7).}

\item{run_echo}{Logical. If TRUE, prints the training result for each lambda being tested (default is FALSE).}

\item{max_iter}{Integer. Maximum number of iterations taken for the solvers to converge (default is 10000).}

\item{tol}{Numeric. Tolerance for stopping criteria (default is 1e-4).}

\item{lr}{Numeric. Learning rate in RMSprop optimizer (default is 0.001).}

\item{alpha}{Numeric. Smoothing constant in RMSprop optimizer (default is 0.9).}

\item{epsilon}{Numeric. Small constant added to the denominator to improve numerical stability (default is 1e-8).}
}
\value{
A list containing two elements:
- `TuningResult`: A data frame of metrics for each lambda, including the number of selected features, prevalence, and performance metrics.
- `PvlDistSummary`: A data frame summarizing prevalence distribution statistics (min, max, quartiles) for selected features at each lambda.
}
\description{
This function performs `LambdaTuningCoxPH` in parallel to accelerate the tuning process.
}
\examples{
set.seed(42)
n_samples <- 10
n_features <- 100

X_raw <- matrix(rnbinom(n_features * n_samples, size = 10, mu = 1), nrow = n_features, ncol = n_samples)
rownames(X_raw) <- paste0('feat',1:n_features)
X_scaled <- t(scale(t(X_raw)))  # feature-wise z-standardization

events <- c('CRC','CRC','health','CRC','health','CRC','health','health','CRC','CRC')
events <- ifelse(events == 'CRC', 1, 0) # 'CRC' sample is 1 and control sample is 0
age <- c(64, 87, 46, 56, 47, 62, 51, 56, 81, 76)

lrange <- AutoScanningCoxPH(X_scaled, X_raw, events, age, step=30)

# How many cores usage available
available_cores <- parallel::detectCores()
available_cores

tuning_res <- LambdaTuningCoxPHParallel(X_scaled, X_raw, events, age, lrange, n_cores = available_cores-2, outpath=getwd())

lmbd_picking <- LambdaDecision(tuning_res$TuningResult, tuning_res$PvlDistSummary)

# optimal lambda
lmbd_picking$opt_lmbd

# segmented regression visualization
library(patchwork)
lmbd_picking$selected_lmbd_plot/lmbd_picking$pvl_plot

}
